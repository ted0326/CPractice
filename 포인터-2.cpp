/*
포인터의 초기화
포인터도 변수이므로 초기화 하지 않을 경우 쓰레기 값 발생
포인터를 초기화 할때 직접 주소를 대입해서는 안된다
포인터 초기화시 16진수를 이용해 직접 대입할 경우 그 주소에 무엇이 들어있는지 모르는데 포인터로 접근해서 변경될수 있기 때문
포인터 사용시 중요한 것은 어떤 변수의 주소인지 아는 것 주소구하기 연산자 & 사용
ex)
int a=10;
int *p3=&a;//여기서 a의 변수값 10의 경우 주소가 계속 변화되는데 운영체제가 메모리 보호를 위해 프로그램을 실행할 때마다 매번 다른주소를 할당해주기 때문

포인터의 사용
포인터를 사용시 두가지 연산자가 필요, 주소를 구할 때 사용하는 &와 변수에 접근하도록 도와주는 역참조연산자 *
주소구하기 연산자는 &다음에 나오는 변수의 주소를 구함
&의 경우 반드시 변수 이름 앞에서만 사용 가능, 상수나 수식어에 사용 불가

역참조 연산자의 경우 포인터 앞에 *를 쓰면 포인터가 가리키는 변수의 값을 읽어 오거나 변경가능
역참조 연산자를 사용하면 그자리에 포인터가 가리키는 변수가 대신 끌려와서 사용됨
역참조 연산자는 간접참조 연산자 라고도 하며 반드시 포인터에만 사용 가능, 포인터가 아닌 변수나 수식에는 사용불가
/*
* int main()
* {
* int x=10;
* int *p=&x;//포인터 p를 a의 주소로 초기화함
* printf("*p=%d",*p);
* *p=20;//x=20;으로 수행됨
* printf("*p=%d",*p);
* return 0;
* }
* 포인터의 용도
* 1.변수의 이름을 직접 사용하는것이 불가능할때
* void test(int *p)//main의 x의 주소로 초기화됨
* {
* *p=20;p가 가르키는 main의 x 를 변경
* }
* 
* int main()
* {
* int x=10;
* test(&x);//x의 주소 전달
* printf("x=%d",x);//x변경
* return 0;
* }
* 
* 2.포인터가 어떤 변수를 가르키게 될 지 모르지만 코드를 작성하는 경우
* if(조건식)
* p=&a;
* else
* p=&b;//조건식에 따라 p는 a 또는 b 를 가리킴 p가 어떤 변수를 가리킬지는 실행 중 결정
* something(*p);p가 가리키는 변수로 함수를 호출
* result=*p*rate+extra;
* *p=some_value;p가 가리키는 변수에 값을 대입
* 포인터가 아니라 변수의 이름을 직접 사용시 비슷한 코드의 반복 발생, 코드 중복은 코드를 어렵게 만듬
* 포인터를 통해 어떤 변수에 대한 처리를 공통의 코드로 수행하게 만들 수 있음
* 
* 포인터 사용 시 주의 사항
* 포인터는 초기화 하고 사용하는 것이 안전
* 포인터를 선언하는 시점에 아직 어떤 변수를 가리켜야 할지 알 수 없을 경우 널 포인터로 초기화
* 
* 포인터의 데이터형과 포인터가 가리키는 변수의 데이터 형이 일치하여야 함
* 
* 알아 두어야 할 것
* *의 용도
* 일반 곱셈
* 변수 선언 시 포인터 수식어로 사용, 이 경우 연산자가 아니라 변수 선언문에서 변수를 포인터로 만드는 역할을 함
* 역참조 연산, 포인터가 가리키는 변수의 접근, 반드시 포인터와 함께 사용
* 
* const 포인터
* 값을 변경 할 수 없는 변수를 선언할 때 사용
* const의 위치에 따라 의미가 달라진다
* 
* const 데이터형*변수
* 포인터가 가리키는 변수의 값 변경 불가
* 변수의 값을 읽는 것만 가능, 읽기 전용 포인터라고도 불림
* ex)
* int a=10,b=20;
* const int*p=&a;
* printf("*p=%d\n",*p)
* *p1=100// 오류, 읽기전용포인터가 되었으므로 값을 변경할 수 없다
* 그러나 포인터 자신의 값, 즉 포인터의 저장된 주소의 경우 변경이 가능하다. 즉 포인터가 다른 변수를 가르키는 것이 가능
* *p=&b;
* printf("*p=%d",*p);//*p의 값으로 b의 값을 출력
* 세가지 const 포인터 중 가장 많이 사용됨
* 
* 데이터형*const 변수
* 포인터의 주소 변경 불가, 특정 변수의 전용 포인터이다.
* 선언 시 반드시 초기화 해야함
* int *const p=&a;//p는 a 전용 포인터가 되어 a에 접근하는 데에만 사용될 수 있다.
* p=&b//오류, 다른 변수를 가르킬 수 없다.
* 
* const 데이터형*const변수
* 읽기전용포인터이면서 특정 변수 정용 포인터가 됨
* 이 경우 반드시 초기화가 필요하며 가르키는 변수의 값도 변경 불가, 주소도 변경 불가이다.
* 
* 포인터의 활용 
* 
* 배열과 포인터의 관계
* 포인터의 연산
* 
* p+n 주소에 포인터가 가리키는 데이터형의 크기*n만큼 더한다.
* p-n 주소에 포인터가 가리키는 데이터형의 크기*n만큼 뺀다
* p1-p2 포인터가 가리키는 데이터형의 개수로 주소의 차를 구한다.
* ++p,p++ 주소를 포인터가 가리키는 데이터형 크기만큼 증가시킨다.
* --p,p-- 주소를 포인터가 가리키는 데이터형 크기만큼 감소시킨다
* p1=p2 같은형의 포인터끼리 대입한다.
* p1==p2 주소가 같은지 비교
* p1!=p2 주소가 다른지 비교
* p[n] 포인터를 배열 이름인 것처럼 사용해서 n번째 원소에 접근
* *p p가 가리키는 변수에 접근
* &p p의 주소를 구함
* p->m p가 가리키는 구조체의 멤버 m에 접근
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p = &arr[0];//p는 arr[0]의 주소를 가짐
	int i;
	for (i = 0; i < 5; i++)
	{
		printf("p=%p,", p);//p의 주소값 출력
		printf("*p=%d\n", *p++);//*p를 출력 후 p++수행 ++연산자가 역참조 연산자보다 우선순위가 높음, *p++는*(p++)의미 즉 p를 증가시킨다 역참조하는 변수를 증가시키기 위해선 *(p)++사용
	}
	return 0;
}
배열처럼 사용되는 포인터
type 형의 포인터는 항상 type형의 변수 또는 type형 배열의 원소를 가리킬 수 있다.

주의 
배열의 주소를 구할 때 & 사용이 불가한 이유
배열 이름 앞에 &을 사용시 예를 들어 &arr처럼 사용시 배열 전체의 주소를 구하는 의미가 되므로 주의하여야한다.

배열 원소를 가리키는 포인터는 배열 이름인 것처럼 사용할 수 있다.
int main()
{
int arr[5]={1,2,3,4,5}
int *p=arr;//배열의 시작주소를 받아준다. arr[0]의 주소와 같음
int i;
for(i=0;i<5;i++)
{
printf("p[%d]=%d\n",i,p[i]);
}
return 0;
}

포인터처럼 사용되는 배열
배열의 이름은 배열의 시작주소를 의미함
즉 arr[i]대신 *(arr+i)도 가능

배열과 포인터의 비교
배열과 포인터는 사용방법은 같으나 본질적으로 다름
배열은 포인터처럼 사용가능하다. 의미의 경우 특정 변수 전용포인터에 해당함 배열의 경우 메모리에 할당되고 나면 배열의 시작 주소를 변경할 수 없다. 즉 대입 연산 혹은 증감연산시 컴파일 에러 발생
int 형 배열 x에 대해 배열이름이 가진 포인터로서의 의미의 코드는 다음과 같다.
int *const x=&x[0];
즉 x는 x배열 전용 포인터란 의미이다. 그러므로 배열이름으로 대입연산은 불가능하다.

반면에 포인터는 값을 변경할 수 있으므로 포인터에 보관된 주소는 변경이 가능하다.

포인터 배열
포인터 배열은 주소를  저장하는 배열 즉 포인터 배열의 각 원소가 다른 변수를 가리키는 포인터이다.
ex)
int *arr[5]={NULL}; //int *형의 변수 5개를 저장하는 배열
arr은 크기가 5인 배열이다
#include<stdio.h>
int main()
{
int a,b,c,d,e;
int *arr[5]={&a,&b,&c,&d,&e};
int i;
for(i=0;i<5;i++)
{
	*arr[i]=i;//arr[i]번째의 원소의 값을 i로 출력시킨다.
	printf("%d",*arr[i]);
 }
 printf("\n");
 printf("%d,%d,%d,%d,%d", a, b, c, d, e);// 앞에서 a b c d e 의 값을 i 입력하였으므로 0 1 2 3 4 가 대입됨
 return 0;
 }
배열에 대한 포인터
배열에 대한 포인터는 배열 전체를 가리키는 포인터이다.
int (*p)[5]=NULL;//int [5]의 주소를 저장하는 포인터
배열에 대한 포인터는 2차원 배열과 함께 사용된다.

int main()
{
int data[3][5]={
	{1,2,3,4,5},
	{6,7,8,9,10},
	{11,12,13,14,15}}
int(*p)[5]=&data[0];//크가가 5인 배열을 주소로 가짐
int i,j;

for(i=0;i<3;i++)
{
	for(j=0;j<5;j++)
	{
	printf("%2d",p[i][j]);
	printf("\n");
	}
}
return 0;
}

이중 포인터
이중 포인터는 포인터의 주소를 저장하는 포인터이다.
int x=10;
int *p=&x;
int **pp=&p;
이중 포인터가 가리키는 변수에 접근할 때도 역참조 연산자를 사용, 이 경우 역참조연산을 2번해야한다.

함수와 포인터
 
 함수의 인자 전달 방법
 1.값에 의한 전달
 함수 호출시 넘겨주는 인자를 매개변수로 복사해서 전달하는 방식
 함수의 매개변수는 함수가 호출될 때 생성되는 지역변수로 함수 호풀 시 넘겨주는 인자의 값으로 초기화됨
ex)
double get_area(double radius)
{
	const double pi=3.14;
	return pi*radius*radius;
}

int main()
{
double result=get_area(2.5);//여기서 2.5가 매겨변수 radius에 대입된다. 인자를 매개변수로 복사해서 전달, 복사에 의한 전달이라고도 함
printf("%f",result);

포인터에 의한 전달
변수의 값을 복사해서 전달하는 대신 변수의 주소를 전달함
void swap(int*x,int*y)매개변수는 포인터형으로 선언됨
swap(&a,&b) //포인터에 의한 전달 사용
즉 int*x=&a,int*y=&b;와 같은의미
포인터에 의한 전달 방법으로 인자를 전달하면 함수 호출 시 넘겨준 주소가 매개변수인 포인터에 저장된다. 따라서 함수 안에서 매개변수인 포인터를 통해서 함수를 호출한 곳에 있는 변수에 접근 가능

void swap(int*x,int*y);

int main()
{
int a=3,b=7;
printf("a=%d,b=%d",a,b);
swap(&a,&b);
printf("a=%d,b=%d",a,b);
return 0;
}
void swap(int*x,int*y)//여기서 *는 포인터의 선언 용도로 사용
{
int temp=*x;//x가 가리키는 변수의 값을 temp에 저장
*x=*y;
* *y=temp;
* }
* 포인터에 의한 전달 방법은 함수의 처리결과를 매개변수로 전달할 때 유용, 함수의 처리결과가 2개 이상인 경우 리턴값을 받을 수 없어 포인터에 의한 전달방법을 이용함
/
함수의 처리결과를 매개변수로 전달하는 과정
void get_sum_product(int x, int y ,int *sum,int *product)

int main()
{
int result 1,result 2;

get_sum_product(10,20,&result1,&result 2);
printf("sum=%d,product=%d\n",result1,result2);
return 0;
}
void get_sum_product(int x, int y ,int *sum,int *product)
{
*sum=x+y;
* *product=x*y;
}

함수의 매개변수는 역할에 따라 크게 3가지로 분류됨

입력 매개변수:함수를 호출한 곳에서 입력을 받아오기 위한 매개변수, 함수안에서 사용될 뿐 변경되진 않는다. x, get_area 에서 radius등이 예시이다. 입력 매개변수는 값으로 전달한다.

출력 매개변수:함수의 출력을 함수로 호출한 곳으로 전달하기 위한 매개변수, 함수안에서 변경된다. get_sum_product 에서 sum과 product 등이 예시이다. 출력매개변수는 포인터로 전달한다.

입출력 매개변수: 함수의 입력과 출력 모두로 사용되는 매개변수, 함수안에서 그 값이 사용되기도 하고 변경도 된다. swap 내에서 x,y가 그 예시이다.포인터로 전달

배열의 전달
배열을 함수의 인자로 전달하려면 크기를 생략한 배열형의 매개변수와 배열의 크기를 전달하는 매개변수 필요
void print_array(int arr[],int size);
c에서 배열을 함수의 인자로 전달 시 항상 포인터로 전달함
void print_array(int *arr,int size);
void print_array(int arr[],int size);//arr[]는 배열의 원소를 가리키는 포인터형이다.arr은 배열처럼 보이나 포인터이므로 sizeof(arr)은 항상 4바이트이다. 따라서 함수안에서 배열의 크기를 구할 수 없어
배열의 크기도 매개변수로 받아와야 한다.
위의 두문장은 같은 뜻이며 둘 중 무엇을 사용하든 상관없다
함수 호출 시 인자로 배열을 전달 하려면 배열의 이름, 즉 시작주소를 전달한다.
배열을 입력 매개변수로 사용하려면 const포인터형의 매개변수를 선언한다.

#include<stdio.h>
#define size 10
void copy_array(const int source[],int target[],int size);
void print_array(const int arr[],int size);

int main()
{
int x[size]={10,20,30,40,50};
int y[size]={0};

printf("x=");
print_array(x,size);
copy_array(x,y,size);
printf("y=");
print_array(y,size);
return 0;
}
void copy_array(const int source[],int target[],int size)
{
	int i;
	for(i=0;i<size;i++)
	{
	target[i]=source[i];
	}
}
void print_array(const int arr[],int size)
{
	int i;
	for(i=0;i<size;i++)
	{
	printf("%d",arr[i]);
	}
	printf("\n");
}

 */
