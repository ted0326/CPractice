/*
포인터의 초기화
포인터도 변수이므로 초기화 하지 않을 경우 쓰레기 값 발생
포인터를 초기화 할때 직접 주소를 대입해서는 안된다
포인터 초기화시 16진수를 이용해 직접 대입할 경우 그 주소에 무엇이 들어있는지 모르는데 포인터로 접근해서 변경될수 있기 때문
포인터 사용시 중요한 것은 어떤 변수의 주소인지 아는 것 주소구하기 연산자 & 사용
ex)
int a=10;
int *p3=&a;//여기서 a의 변수값 10의 경우 주소가 계속 변화되는데 운영체제가 메모리 보호를 위해 프로그램을 실행할 때마다 매번 다른주소를 할당해주기 때문

포인터의 사용
포인터를 사용시 두가지 연산자가 필요, 주소를 구할 때 사용하는 &와 변수에 접근하도록 도와주는 역참조연산자 *
주소구하기 연산자는 &다음에 나오는 변수의 주소를 구함
&의 경우 반드시 변수 이름 앞에서만 사용 가능, 상수나 수식어에 사용 불가

역참조 연산자의 경우 포인터 앞에 *를 쓰면 포인터가 가리키는 변수의 값을 읽어 오거나 변경가능
역참조 연산자를 사용하면 그자리에 포인터가 가리키는 변수가 대신 끌려와서 사용됨
역참조 연산자는 간접참조 연산자 라고도 하며 반드시 포인터에만 사용 가능, 포인터가 아닌 변수나 수식에는 사용불가
/*
* int main()
* {
* int x=10;
* int *p=&x;//포인터 p를 a의 주소로 초기화함
* printf("*p=%d",*p);
* *p=20;//x=20;으로 수행됨
* printf("*p=%d",*p);
* return 0;
* }
* 포인터의 용도
* 1.변수의 이름을 직접 사용하는것이 불가능할때
* void test(int *p)//main의 x의 주소로 초기화됨
* {
* *p=20;p가 가르키는 main의 x 를 변경
* }
* 
* int main()
* {
* int x=10;
* test(&x);//x의 주소 전달
* printf("x=%d",x);//x변경
* return 0;
* }
* 
* 2.포인터가 어떤 변수를 가르키게 될 지 모르지만 코드를 작성하는 경우
* if(조건식)
* p=&a;
* else
* p=&b;//조건식에 따라 p는 a 또는 b 를 가리킴 p가 어떤 변수를 가리킬지는 실행 중 결정
* something(*p);p가 가리키는 변수로 함수를 호출
* result=*p*rate+extra;
* *p=some_value;p가 가리키는 변수에 값을 대입
* 포인터가 아니라 변수의 이름을 직접 사용시 비슷한 코드의 반복 발생, 코드 중복은 코드를 어렵게 만듬
* 포인터를 통해 어떤 변수에 대한 처리를 공통의 코드로 수행하게 만들 수 있음
* 
* 포인터 사용 시 주의 사항
* 포인터는 초기화 하고 사용하는 것이 안전
* 포인터를 선언하는 시점에 아직 어떤 변수를 가리켜야 할지 알 수 없을 경우 널 포인터로 초기화
* 
* 포인터의 데이터형과 포인터가 가리키는 변수의 데이터 형이 일치하여야 함
* 
* 알아 두어야 할 것
* *의 용도
* 일반 곱셈
* 변수 선언 시 포인터 수식어로 사용, 이 경우 연산자가 아니라 변수 선언문에서 변수를 포인터로 만드는 역할을 함
* 역참조 연산, 포인터가 가리키는 변수의 접근, 반드시 포인터와 함께 사용
* 
* const 포인터
* 값을 변경 할 수 없는 변수를 선언할 때 사용
* const의 위치에 따라 의미가 달라진다
* 
* const 데이터형*변수
* 포인터가 가리키는 변수의 값 변경 불가
* 변수의 값을 읽는 것만 가능, 읽기 전용 포인터라고도 불림
* ex)
* int a=10,b=20;
* const int*p=&a;
* printf("*p=%d\n",*p)
* *p1=100// 오류, 읽기전용포인터가 되었으므로 값을 변경할 수 없다
* 그러나 포인터 자신의 값, 즉 포인터의 저장된 주소의 경우 변경이 가능하다. 즉 포인터가 다른 변수를 가르키는 것이 가능
* *p=&b;
* printf("*p=%d",*p);//*p의 값으로 b의 값을 출력
* 세가지 const 포인터 중 가장 많이 사용됨
* 
* 데이터형*const 변수
* 포인터의 주소 변경 불가, 특정 변수의 전용 포인터이다.
* 선언 시 반드시 초기화 해야함
* int *const p=&a;//p는 a 전용 포인터가 되어 a에 접근하는 데에만 사용될 수 있다.
* p=&b//오류, 다른 변수를 가르킬 수 없다.
* 
* const 데이터형*const변수
* 읽기전용포인터이면서 특정 변수 정용 포인터가 됨
* 이 경우 반드시 초기화가 필요하며 가르키는 변수의 값도 변경 불가, 주소도 변경 불가이다.
* 
* 포인터의 활용 
* 
* 배열과 포인터의 관계
* 포인터의 연산
* 
* p+n 주소에 포인터가 가리키는 데이터형의 크기*n만큼 더한다.
* p-n 주소에 포인터가 가리키는 데이터형의 크기*n만큼 뺀다
* p1-p2 포인터가 가리키는 데이터형의 개수로 주소의 차를 구한다.
* ++p,p++ 주소를 포인터가 가리키는 데이터형 크기만큼 증가시킨다.
* --p,p-- 주소를 포인터가 가리키는 데이터형 크기만큼 감소시킨다
* p1=p2 같은형의 포인터끼리 대입한다.
* p1==p2 주소가 같은지 비교
* p1!=p2 주소가 다른지 비교
* p[n] 포인터를 배열 이름인 것처럼 사용해서 n번째 원소에 접근
* *p p가 가리키는 변수에 접근
* &p p의 주소를 구함
* p->m p가 가리키는 구조체의 멤버 m에 접근
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int* p = &arr[0];//p는 arr[0]의 주소를 가짐
	int i;
	for (i = 0; i < 5; i++)
	{
		printf("p=%p,", p);//p의 주소값 출력
		printf("*p=%d\n", *p++);//*p를 출력 후 p++수행 ++연산자가 역참조 연산자보다 우선순위가 높음, *p++는*(p++)의미 즉 p를 증가시킨다 역참조하는 변수를 증가시키기 위해선 *(p)++사용
	}
	return 0;
}
배열처럼 사용되는 포인터
type 형의 포인터는 항상 type형의 변수 또는 type형 배열의 원소를 가리킬 수 있다.

주의 
배열의 주소를 구할 때 & 사용이 불가한 이유
배열 이름 앞에 &을 사용시 예를 들어 &arr처럼 사용시 배열 전체의 주소를 구하는 의미가 되므로 주의하여야한다.

배열 원소를 가리키는 포인터는 배열 이름인 것처럼 사용할 수 있다.
int main()
{
int arr[5]={1,2,3,4,5}
int *p=arr;//배열의 시작주소를 받아준다. arr[0]의 주소와 같음
int i;
for(i=0;i<5;i++)
{
printf("p[%d]=%d\n",i,p[i]);
}
return 0;
}

포인터처럼 사용되는 배열
배열의 이름은 배열의 시작주소를 의미함
즉 arr[i]대신 *(arr+i)도 가능

배열과 포인터의 비교
배열과 포인터는 사용방법은 같으나 본질적으로 다름
배열은 포인터처럼 사용가능하다. 의미의 경우 특정 변수 전용포인터에 해당함 배열의 경우 메모리에 할당되고 나면 배열의 시작 주소를 변경할 수 없다. 즉 대입 연산 혹은 증감연산시 컴파일 에러 발생
int 형 배열 x에 대해 배열이름이 가진 포인터로서의 의미의 코드는 다음과 같다.
int *const x=&x[0];
즉 x는 x배열 전용 포인터란 의미이다. 그러므로 배열이름으로 대입연산은 불가능하다.

반면에 포인터는 값을 변경할 수 있으므로 포인터에 보관된 주소는 변경이 가능하다.

포인터 배열
포인터 배열은 주소를  저장하는 배열 즉 포인터 배열의 각 원소가 다른 변수를 가리키는 포인터이다.
ex)
int *arr[5]={NULL}; //int *형의 변수 5개를 저장하는 배열
arr은 크기가 5인 배열이다
#include<stdio.h>
int main()
{
int a,b,c,d,e;
int *arr[5]={&a,&b,&c,&d,&e};
int i;
for(i=0;i<5;i++)
{
	*arr[i]=i;//arr[i]번째의 원소의 값을 i로 출력시킨다.
	printf("%d",*arr[i]);
 }
 printf("\n");
 printf("%d,%d,%d,%d,%d", a, b, c, d, e);// 앞에서 a b c d e 의 값을 i 입력하였으므로 0 1 2 3 4 가 대입됨
 return 0;
 }

 */
